--NINE WAYS TO GET DISTICT DUPLICATE RECORDS PLSQL
SELECT UNIQUE TBL.* FROM TESTING_TBL TBL;

SELECT NUMBER_1,NUMBER_2
FROM TESTING_TBL
GROUP BY NUMBER_1,NUMBER_2
ORDER BY NUMBER_1;

SELECT NUMBER_1,NUMBER_2
FROM TESTING_TBL
UNION
SELECT NUMBER_1,NUMBER_2
FROM TESTING_TBL;


SELECT NUMBER_1,NUMBER_2
FROM TESTING_TBL
UNION
SELECT NULL,NULL
FROM DUAL;

SELECT NUMBER_1,NUMBER_2
FROM TESTING_TBL
INTERSECT
SELECT NUMBER_1,NUMBER_2
FROM TESTING_TBL;

-- THESE BELOW WILL ALSO REMOVE THE NULL,NULL VALUE
SELECT NUMBER_1,NUMBER_2
FROM TESTING_TBL
MINUS
SELECT NULL,NULL
FROM DUAL;

SELECT NUMBER_1,NUMBER_2 FROM (
    SELECT NUMBER_1,NUMBER_2,
    ROW_NUMBER() OVER(PARTITION BY NUMBER_1,NUMBER_2
                        ORDER BY NUMBER_1,NUMBER_2) R
    FROM TESTING_TBL
)
WHERE R=1;

SELECT NUMBER_1,NUMBER_2 FROM(
    SELECT NUMBER_1,NUMBER_2,
        RANK() OVER(PARTITION BY NUMBER_1,NUMBER_2
                            ORDER BY ROWNUM) R
        FROM TESTING_TBL
    )
WHERE R=1;

--MAX(ROWID) OR MIN(ROWID) WILL GIVE SAME RESULT
SELECT * FROM TESTING_TBL
WHERE ROWID IN(
    SELECT MIN(ROWID)
    FROM TESTING_TBL
    GROUP BY NUMBER_1,NUMBER_2
)
ORDER BY NUMBER_1,NUMBER_2;

--THIS WILL DO DISTINCT AND ALSO REMOVE THE THE ROW WHICH COLUMN CONTAIN NULL VALUE
SELECT * FROM TESTING_TBL A
WHERE 1=(
    SELECT COUNT(1)
    FROM TESTING_TBL B
    WHERE
        A.NUMBER_1=B.NUMBER_1
        AND A.NUMBER_2=B.NUMBER_2
        AND A.ROWID>=B.ROWID
);

--DECODE WILL DO EQUALITY ASSOCIATION ONLY
--DECODE WILL ACCEPT THE VALUES EVEN THE DATATYPE IS DIFFERENT
--DECODE CAN ONLY BE USED AS PART OF THE SELECT STATEMENT
SELECT * FROM (
    SELECT
        NUMBER_1,
        NUMBER_2,
        DECODE(
            ABS(NUMBER_1/10),1,'BILANGAN 10',
            2,'BILANGAN 20',
            3,'BILANGAN 30','TIDAK JELAS') "HASIL"
    FROM TESTING_TBL
)
WHERE HASIL<>'TIDAK JELAS';

SELECT
    NUMBER_1,
    NUMBER_2,
    CASE 
        WHEN NUMBER_2<20 THEN 'BELOW 20'
        WHEN NUMBER_2>=20 THEN 'ABOVE 20'
        ELSE 'UNDETECT'
    END
FROM TESTING_TBL;

SELECT
    NUMBER_1,
    NUMBER_2,
    CASE ABS(NUMBER_1/10)
        WHEN 1 THEN 'BIL 10'
        WHEN 2 THEN 'BIL 20'
        WHEN 3 THEN 'BIL 30'
        ELSE 'UNDETECT'
    END
FROM TESTING_TBL 

--WILL CHANGE THE CHARACTER
SELECT REPLACE('WELCOME TO ORACLE CLASS','ORACLE',NULL)
FROM DUAL;

--WILL CHANGE THE WORD
SELECT TRANSLATE('WELCOME TO ORACLE CLASS','AIUEO','12345')
FROM DUAL

CREATE OR REPLACE PROCEDURE USP_MULTIPLE_INTO(
    P_NIK IN VARCHAR2
)AS
    V_NAME   VARCHAR2(100);
    V_NIK    VARCHAR2(20);
    V_POS_ID NUMERIC;
BEGIN
    SELECT 
        NAME,
        NIK,
        POS_ID 
        INTO V_NAME,V_NIK,V_POS_ID
    FROM EMP_HR HR
    JOIN CASHIER_POS_RECORD CPR
    ON HR.ID=CPR.CASHIER_ID
    WHERE HR.NIK=P_NIK
    FETCH FIRST 1 ROW ONLY;
END

DECLARE
    V1      NUMERIC:=10;
    V2      NUMERIC:=0;
    V_RES   NUMERIC;
BEGIN
    V_RES:=V1/V2;
--    EXCEPTION WHEN ZERO_DIVIDER THEN
    EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('SQLERRM= '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('SQLCODE= '||SQLCODE);
END;

--DELETE DUPLICATE RECORD ---

DELETE FROM TESTING_TBL
WHERE ROWID NOT IN(
    SELECT MAX(ROWID)
    FROM TESTING_TBL
    GROUP BY NUMBER_1,NUMBER_2
);

DELETE
FROM TESTING_TBL A
WHERE ROWID<(
    SELECT MAX(ROWID)
    FROM TESTING_TBL B
    WHERE
        A.NUMBER_1=B.NUMBER_1
        AND A.NUMBER_2=B.NUMBER_2);

DELETE
FROM TESTING_TBL A
WHERE ROWID>(
    SELECT MINS(ROWID)
    FROM TESTING_TBL B
    WHERE
        A.NUMBER_1=B.NUMBER_1
        AND A.NUMBER_2=B.NUMBER_2);

---------------------------------------

INSERT INTO TESTING_TBL(NUMBER_1,NUMBER_2)
    SELECT LEVEL,LEVEL-1 "PATHLEN"
    FROM DUAL
    CONNECT BY LEVEL<=30;

--FLASHBACK QUERY
-- RETURNING THE DELETED DATA BACK
INSERT INTO TESTING_TBL(
SELECT * FROM TESTING_TBL AS OF TIMESTAMP
    TO_TIMESTAMP('2021-10-21 10:00:00','YYYY-MM-DD HH:MI:SS')
    WHERE NUMBER_1=1 AND NUMBER_2=0);

-------------------------------------ANALYTICAL FUNCTION---------------------

--UNPIVOT (TRANSFORM COLUMN INTO ROW), EXAMPLE BELOW AS KEY VALUE PAIR
SELECT * FROM(
    SELECT NAME,POSITION,JOB_DESC,NIK 
    FROM EMP_HR
)UNPIVOT(MY_VALUE
        FOR MY_KEY 
        IN(NAME,POSITION,NIK));

--PIVOT (TRANSFORM ROWS INTO COLUMNS)
SELECT * FROM(
    SELECT NIK,NAME,POSITION FROM EMP_HR)
    PIVOT(MAX(NAME) 
--            COUNT(*) CNT
            FOR POSITION 
            IN('CASHIER','CHEF','CS','MANAGER'));
            
SELECT 
    HR.*,
    (SELECT SUM(E.SALARY) FROM EMP_HR E) AS SAL
FROM EMP_HR HR;

SELECT 
    HR.*,
    SUM(HR.SALARY) OVER() AS SAL
FROM EMP_HR HR;

-- THE ORDER BY CHANGE THE WAY CALCULATING THE SUM
SELECT 
    HR.*,
    SUM(HR.SALARY) OVER(ORDER BY NAME) AS SAL
FROM EMP_HR HR;

--CALCULATE EMPLOYEE SALARY AS PORTION OF THE TOTAL COMPANY SALARIES
SELECT 
    HR.*,
    HR.SALARY/SUM(HR.SALARY) OVER() AS SAL
FROM EMP_HR HR;

--GET THE TOTAL SALARY FOR EACH DEPARTMENT
SELECT POSITION, SUM(HR.SALARY)
FROM EMP_HR HR
GROUP BY POSITION;

-- WILL GIVE SAME RESULT AS ABOVE GROUP BY
SELECT
    HR.*,
    SUM(HR.SALARY) OVER(PARTITION BY POSITION) AS TOTAL
FROM EMP_HR HR;

--SAME RESULT AS ABOVE
SELECT 
    HR.*,
    (SELECT SUM(HR2.SALARY)
        FROM EMP_HR HR2
        WHERE HR2.POSITION=HR.POSITION) AS SAL_SUM
FROM EMP_HR HR
ORDER BY HR.ID;

--ACCUMULATIE COUNT
SELECT
    HR.*,
    SUM(HR.SALARY) OVER(PARTITION BY POSITION ORDER BY SALARY) "ACCUMULATIVE SUM"
FROM EMP_HR HR
ORDER BY POSITION;

-- PARTITION BY /GROUP BY SALARY, AND THEN ORDERING THE SALARY DESCENDING
-- ROW_NUMBER GENERATES UNIQUE NUMBER FOR A ROW
SELECT
    HR.*,
    ROW_NUMBER() OVER(PARTITION BY POSITION ORDER BY SALARY DESC) UNIQUE_ROW
FROM EMP_HR HR;

-- RANK_NUMBER() ASSIGN THE UNIQUE RANK, ORDER BY SALARY
-- SO IF THE SALARY IS REPEATING, IT WILL GIVE THE SAME UNIQUE NUMBER
SELECT
    HR.*,
    RANK() OVER(PARTITION BY POSITION ORDER BY SALARY DESC) UNIQUE_RANK
FROM EMP_HR HR;

--SAME AS RANK() FUNCTION, BUT THE NUMBER WILL ADD CONTINOUSLY, NOT BEING SKIPPED
SELECT
    HR.*,
    DENSE_RANK() OVER(PARTITION BY POSITION ORDER BY SALARY DESC) UNIQUE_RANK
FROM EMP_HR HR;

--LAG (SALARY,1,0): FROM THE SALARY COLUMN, THE BEFORE ROW, WITH OFFSET OF 1 (THE FIRST BEFORE ROW)
SELECT
    HR.*,
    LAG(SALARY,1,0) OVER(PARTITION BY POSITION ORDER BY SALARY) BEFORE_SAL
FROM EMP_HR HR;

-- TO GET THE DIFFERENCE CURRENT SALARY WITH THE BEFORE (ROW) SALARY
SELECT
    HR.*,
    LAG(SALARY,1,0) OVER(PARTITION BY POSITION ORDER BY SALARY) BEFORE_SAL,
    SALARY-LAG(SALARY,1,0) OVER(PARTITION BY POSITION ORDER BY SALARY) DIFFERENCE_SAL
FROM EMP_HR HR;

-- LEAD() ; IS FOR THE NEXT ROW
SELECT
    HR.*,
    LEAD(SALARY,1,0) OVER(PARTITION BY POSITION ORDER BY SALARY) AFTER_SAL,
    LEAD(SALARY,1,0) OVER(PARTITION BY POSITION ORDER BY SALARY) -SALARY DIFFERENCE_SAL
FROM EMP_HR HR;

-- FIRST_VALUE, TO GET THE LOWEST SALARY / CHANGE TO DESC TO MAKE IT GET THE HIGHEST VALUE
-- LAST_VALUE, TO GET THE HIGHEST SALARY. WHY USE IT? SO THE DATABASE CAN TAKE ADVANTAGE, JUST BY ORDERING THE DATA ONCE
-- NTH_VALUE, TO GET THE FIFTH ROW SALARY, "FROM FIRST" INDICATE IT START FROM THE FIRST OFFSET
-- "FROM LAST" TO GET THE N LAST ROW SALARY
-- ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING, SO IT WILL ANALYZE FROM FIRST ROW UNTIL THE LAST ROW OF THE WINDOW
SELECT
    HR.*,
    FIRST_VALUE(SALARY) OVER(PARTITION BY POSITION ORDER BY SALARY) LOWEST_VAL,
    LAST_VALUE(SALARY) OVER(PARTITION BY POSITION ORDER BY SALARY
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) HIGHEST_VAL,
    NTH_VALUE(SALARY,5) FROM FIRST OVER(PARTITION BY POSITION ORDER BY SALARY
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FIFTH_VAL,
    SALARY-FIRST_VALUE(SALARY) OVER(PARTITION BY POSITION ORDER BY SALARY) DIFFERENCE_SAL
FROM EMP_HR HR;

-- NTILE OVER (ORDER BY ...) IS A MUST
-- BELOW NTILE() WILL SPLIT SALARY INTO 3 GROUP, PARTITION BY POSITION
SELECT
    NTILE(3) OVER (PARTITION BY POSITION ORDER BY SALARY) TILES,
    HR.NAME,HR.POSITION,HR.NIK,
    NULL START_RANGE,
    NULL END_RANGE
FROM EMP_HR HR
UNION ALL
SELECT
    NULL TILES,
    NULL NAME, NULL POSITION, NULL NIK,
    MIN(SALARY) START_RANGE,
    MAX(SALARY) END_RANGE
FROM EMP_HR HR2
ORDER BY NAME NULLS FIRST;

--PRACTICAL EXAMPLE FOR RANK() OVER USE CASE:
SELECT
    ID
    ,COND
    ,R
FROM(
    SELECT DISTINCT
        ID
        , FN_SOMETHING(KONDISI) COND
        , RANK() OVER(PARTITION BY FN_CEK_BERAT(KONDISI) ORDER BY ID) R
    FROM TABLE_TEST_SORT
)
WHERE COND=1 OR (COND=0 AND R=1);