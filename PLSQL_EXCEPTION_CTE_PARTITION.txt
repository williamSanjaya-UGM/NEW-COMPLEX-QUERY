create or replace PROCEDURE USP_PLSQL_CTE(
    P_CUR_OUT OUT SYS_REFCURSOR
)AS
    V_COL TYP_HIERAR;
BEGIN
    --CREATING HIEARCHY TABLE WITH CTE
    WITH HIERAR_TBL(ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT ID,NAME,DETAIL_ID,PARENT_ID, 1 AS NUMS_LVL
        FROM TEST_MAPPING
        WHERE PARENT_ID IS NULL
        UNION ALL
        SELECT MAP2.ID,MAP2.NAME,MAP2.DETAIL_ID,MAP2.PARENT_ID, HTBL.NUMS_LVL +1
        FROM TEST_MAPPING MAP2
        JOIN HIERAR_TBL HTBL 
        ON HTBL.ID=MAP2.PARENT_ID
        WHERE MAP2.PARENT_ID IS NOT NULL
    )SELECT OBJ_HIERAR(
        ID,
        NAME,
        DETAIL_ID,
        PARENT_ID,
        NUMS_LVL
    ) BULK COLLECT INTO V_COL FROM (
        SELECT
            ID,
            NAME,
            DETAIL_ID,
            PARENT_ID,
            NUMS_LVL
        FROM HIERAR_TBL
    );
    
    OPEN P_CUR_OUT FOR
    SELECT * FROM TABLE(V_COL);

END;

create or replace PROCEDURE USP_PLSQL_CTE_UPPER_HIERAR(
    P_LVL IN NUMERIC,
    P_CUR_OUT OUT SYS_REFCURSOR
)AS
    V_COL TYP_HIERAR;
BEGIN
    --CREATING HIEARCHY TABLE WITH CTE WHERE CLAUSE
    WITH HIERAR_TBL(ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT ID,NAME,DETAIL_ID,PARENT_ID, 1 AS NUMS_LVL
        FROM TEST_MAPPING
        WHERE PARENT_ID IS NULL
        UNION ALL
        SELECT MAP2.ID,MAP2.NAME,MAP2.DETAIL_ID,MAP2.PARENT_ID, HTBL.NUMS_LVL +1
        FROM TEST_MAPPING MAP2
        JOIN HIERAR_TBL HTBL 
        ON HTBL.ID=MAP2.PARENT_ID
        WHERE MAP2.PARENT_ID IS NOT NULL
    ),
    UPPER_HIERAR (ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT 
            ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL
        FROM HIERAR_TBL
        WHERE NUMS_LVL>NVL(P_LVL,0)
    )SELECT OBJ_HIERAR(
        ID,
        NAME,
        DETAIL_ID,
        PARENT_ID,
        NUMS_LVL
    ) BULK COLLECT INTO V_COL FROM (
        SELECT
            ID,
            NAME,
            DETAIL_ID,
            PARENT_ID,
            NUMS_LVL
        FROM UPPER_HIERAR
    );

    OPEN P_CUR_OUT FOR
    SELECT * FROM TABLE(V_COL);

END;

create or replace PROCEDURE USP_PLSQL_CTE_INSERT(
    P_LVL IN NUMERIC
)AS
BEGIN
    INSERT INTO DUMP_S_TESTING_TBL
    WITH HIERAR_TBL(ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT ID,NAME,DETAIL_ID,PARENT_ID, 1 AS NUMS_LVL
        FROM TEST_MAPPING
        WHERE PARENT_ID IS NULL
        UNION ALL
        SELECT MAP2.ID,MAP2.NAME,MAP2.DETAIL_ID,MAP2.PARENT_ID, HTBL.NUMS_LVL +1
        FROM TEST_MAPPING MAP2
        JOIN HIERAR_TBL HTBL 
        ON HTBL.ID=MAP2.PARENT_ID
        WHERE MAP2.PARENT_ID IS NOT NULL
    ),
    UPPER_HIERAR (ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT 
            ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL
        FROM HIERAR_TBL
        WHERE NUMS_LVL>NVL(P_LVL,0)
    ) 
    SELECT
        ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL
    FROM UPPER_HIERAR;

END;

-- ERROR HANDLING
--RAISE, TYPICALLY WILL RAISE THE ERROR WITHIN THE BLOCK INSIDE THE PROCEDURE ITSELF
--RAISE_APPLICATION_ERROR, WILL USED TO THROWBACK TO THE CALLING PLACE

--RAISE WILL JUST THROW THE EXCEPTION WITH, ORA-06510: "UNHANDLED USER-DEFINED EXCEPTION"
DECLARE
    V_EXCEP EXCEPTION;
    V_2 NUMERIC:=0;
BEGIN

    IF V_2 = 0 THEN
        RAISE V_EXCEP;
    END IF;
    
    EXCEPTION WHEN V_EXCEP THEN
        DBMS_OUTPUT.PUT_LINE('EXCEPTION RAISED');
END;
/

DECLARE
    V_NUMS NUMERIC;
    V_INTO_NUM NUMERIC;
    V_EXCEPTION_INIT EXCEPTION;
    PRAGMA EXCEPTION_INIT(V_EXCEPTION_INIT,-06502);
BEGIN
    V_NUMS:=999999999999999999999990000000000000000;
    
    SELECT V_NUMS INTO V_INTO_NUM
    FROM DUAL;
    
    DBMS_OUTPUT.PUT_LINE(V_INTO_NUM);
    
    EXCEPTION WHEN V_EXCEPTION_INIT THEN
        DBMS_OUTPUT.PUT_LINE('EXCEPTION HANDLED');
END;
/

--RAISE_APPLICATION_ERROR WILL RAISE EXCEPTION JUST LIKE ANY OTHER NORMAL ERROR REPORT: EXAMPLE: "ORA-20001: V_2 MUST NOT BE ZERO"
DECLARE
    V_EXCEP EXCEPTION;
    V_2 NUMERIC:=0;
BEGIN
    -- THE SQLCODE MUST BE BETWEEN -20001 UNTIL 20999
    IF V_2 = 0 THEN
        RAISE_APPLICATION_ERROR (-20001,'V_2 MUST NOT BE ZERO');
    END IF;
    
    EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('SQLERRM '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('SQLCODE '||SQLCODE);
END;
/

----CORRELATED SUBQUERY---
SELECT * FROM EMP_HR A
WHERE ID IN(
    SELECT CASHIER_ID
    FROM CASHIER_POS_RECORD B
    WHERE A.ID=B.CASHIER_ID
    );
    
SELECT * FROM EMP_HR A
WHERE 1 =(
    SELECT COUNT(1)
    FROM CASHIER_POS_RECORD B
    WHERE A.ID=B.CASHIER_ID
    );

--WHERE 1 MEANS "IS TRUE"

---GROUP BY, OVER PARTITION
--BELOW WILL GIVE THE SAME RESULT AS GROUP BY
SELECT COUNT(NAME), POSITION
FROM EMP_HR
GROUP BY POSITION;

SELECT DISTINCT
    COUNT(NAME) OVER(PARTITION BY POSITION),
    POSITION
FROM EMP_HR;

SELECT SUM(SALARY), POSITION
FROM EMP_HR
GROUP BY POSITION;

SELECT DISTINCT
    SUM(SALARY) OVER (PARTITION BY POSITION),
    POSITION
FROM EMP_HR;

SELECT COUNT(NAME), SUM(SALARY), POSITION
FROM EMP_HR
GROUP BY POSITION;

SELECT DISTINCT
    COUNT(NAME) OVER(PARTITION BY POSITION),
    SUM(SALARY) OVER (PARTITION BY POSITION),
    POSITION
FROM EMP_HR;

--ARTHMETIC NULL & DUAL
SELECT 1+NULL
FROM DUAL;