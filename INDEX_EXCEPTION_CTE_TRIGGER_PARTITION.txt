create or replace PROCEDURE USP_PLSQL_CTE(
    P_CUR_OUT OUT SYS_REFCURSOR
)AS
    V_COL TYP_HIERAR;
BEGIN
    --CREATING HIEARCHY TABLE WITH CTE
    WITH HIERAR_TBL(ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT ID,NAME,DETAIL_ID,PARENT_ID, 1 AS NUMS_LVL
        FROM TEST_MAPPING
        WHERE PARENT_ID IS NULL
        UNION ALL
        SELECT MAP2.ID,MAP2.NAME,MAP2.DETAIL_ID,MAP2.PARENT_ID, HTBL.NUMS_LVL +1
        FROM TEST_MAPPING MAP2
        JOIN HIERAR_TBL HTBL 
        ON HTBL.ID=MAP2.PARENT_ID
        WHERE MAP2.PARENT_ID IS NOT NULL
    )SELECT OBJ_HIERAR(
        ID,
        NAME,
        DETAIL_ID,
        PARENT_ID,
        NUMS_LVL
    ) BULK COLLECT INTO V_COL FROM (
        SELECT
            ID,
            NAME,
            DETAIL_ID,
            PARENT_ID,
            NUMS_LVL
        FROM HIERAR_TBL
    );
    
    OPEN P_CUR_OUT FOR
    SELECT * FROM TABLE(V_COL);

END;

create or replace PROCEDURE USP_PLSQL_CTE_UPPER_HIERAR(
    P_LVL IN NUMERIC,
    P_CUR_OUT OUT SYS_REFCURSOR
)AS
    V_COL TYP_HIERAR;
BEGIN
    --CREATING HIEARCHY TABLE WITH CTE WHERE CLAUSE
    WITH HIERAR_TBL(ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT ID,NAME,DETAIL_ID,PARENT_ID, 1 AS NUMS_LVL
        FROM TEST_MAPPING
        WHERE PARENT_ID IS NULL
        UNION ALL
        SELECT MAP2.ID,MAP2.NAME,MAP2.DETAIL_ID,MAP2.PARENT_ID, HTBL.NUMS_LVL +1
        FROM TEST_MAPPING MAP2
        JOIN HIERAR_TBL HTBL 
        ON HTBL.ID=MAP2.PARENT_ID
        WHERE MAP2.PARENT_ID IS NOT NULL
    ),
    UPPER_HIERAR (ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT 
            ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL
        FROM HIERAR_TBL
        WHERE NUMS_LVL>NVL(P_LVL,0)
    )SELECT OBJ_HIERAR(
        ID,
        NAME,
        DETAIL_ID,
        PARENT_ID,
        NUMS_LVL
    ) BULK COLLECT INTO V_COL FROM (
        SELECT
            ID,
            NAME,
            DETAIL_ID,
            PARENT_ID,
            NUMS_LVL
        FROM UPPER_HIERAR
    );

    OPEN P_CUR_OUT FOR
    SELECT * FROM TABLE(V_COL);

END;

create or replace PROCEDURE USP_PLSQL_CTE_INSERT(
    P_LVL IN NUMERIC
)AS
BEGIN
    INSERT INTO DUMP_S_TESTING_TBL
    WITH HIERAR_TBL(ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT ID,NAME,DETAIL_ID,PARENT_ID, 1 AS NUMS_LVL
        FROM TEST_MAPPING
        WHERE PARENT_ID IS NULL
        UNION ALL
        SELECT MAP2.ID,MAP2.NAME,MAP2.DETAIL_ID,MAP2.PARENT_ID, HTBL.NUMS_LVL +1
        FROM TEST_MAPPING MAP2
        JOIN HIERAR_TBL HTBL 
        ON HTBL.ID=MAP2.PARENT_ID
        WHERE MAP2.PARENT_ID IS NOT NULL
    ),
    UPPER_HIERAR (ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL) AS(
        SELECT 
            ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL
        FROM HIERAR_TBL
        WHERE NUMS_LVL>NVL(P_LVL,0)
    ) 
    SELECT
        ID,NAME,DETAIL_ID,PARENT_ID,NUMS_LVL
    FROM UPPER_HIERAR;

END;

-- ERROR HANDLING
--RAISE, TYPICALLY WILL RAISE THE ERROR WITHIN THE BLOCK INSIDE THE PROCEDURE ITSELF
--RAISE_APPLICATION_ERROR, WILL USED TO THROWBACK TO THE CALLING PLACE

--RAISE WILL JUST THROW THE EXCEPTION WITH, ORA-06510: "UNHANDLED USER-DEFINED EXCEPTION"
DECLARE
    V_EXCEP EXCEPTION;
    V_2 NUMERIC:=0;
BEGIN

    IF V_2 = 0 THEN
        RAISE V_EXCEP;
    END IF;
    
    EXCEPTION WHEN V_EXCEP THEN
        DBMS_OUTPUT.PUT_LINE('EXCEPTION RAISED');
END;
/

DECLARE
    V_NUMS NUMERIC;
    V_INTO_NUM NUMERIC;
    V_EXCEPTION_INIT EXCEPTION;
    PRAGMA EXCEPTION_INIT(V_EXCEPTION_INIT,-06502);
BEGIN
    V_NUMS:=999999999999999999999990000000000000000;
    
    SELECT V_NUMS INTO V_INTO_NUM
    FROM DUAL;
    
    DBMS_OUTPUT.PUT_LINE(V_INTO_NUM);
    
    EXCEPTION WHEN V_EXCEPTION_INIT THEN
        DBMS_OUTPUT.PUT_LINE('EXCEPTION HANDLED');
END;
/

--RAISE_APPLICATION_ERROR WILL RAISE EXCEPTION JUST LIKE ANY OTHER NORMAL ERROR REPORT: EXAMPLE: "ORA-20001: V_2 MUST NOT BE ZERO"
DECLARE
    V_EXCEP EXCEPTION;
    V_2 NUMERIC:=0;
BEGIN
    -- THE SQLCODE MUST BE BETWEEN -20001 UNTIL 20999
    IF V_2 = 0 THEN
        RAISE_APPLICATION_ERROR (-20001,'V_2 MUST NOT BE ZERO');
    END IF;
    
    EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('SQLERRM '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('SQLCODE '||SQLCODE);
END;
/

----CORRELATED SUBQUERY---
SELECT * FROM EMP_HR A
WHERE ID IN(
    SELECT CASHIER_ID
    FROM CASHIER_POS_RECORD B
    WHERE A.ID=B.CASHIER_ID
    );
    
SELECT * FROM EMP_HR A
WHERE 1 =(
    SELECT COUNT(1)
    FROM CASHIER_POS_RECORD B
    WHERE A.ID=B.CASHIER_ID
    );

--WHERE 1 MEANS "IS TRUE"

---GROUP BY, OVER PARTITION
--BELOW WILL GIVE THE SAME RESULT AS GROUP BY
SELECT COUNT(NAME), POSITION
FROM EMP_HR
GROUP BY POSITION;

SELECT DISTINCT
    COUNT(NAME) OVER(PARTITION BY POSITION),
    POSITION
FROM EMP_HR;

SELECT SUM(SALARY), POSITION
FROM EMP_HR
GROUP BY POSITION;

SELECT DISTINCT
    SUM(SALARY) OVER (PARTITION BY POSITION),
    POSITION
FROM EMP_HR;

SELECT COUNT(NAME), SUM(SALARY), POSITION
FROM EMP_HR
GROUP BY POSITION;

SELECT DISTINCT
    COUNT(NAME) OVER(PARTITION BY POSITION),
    SUM(SALARY) OVER (PARTITION BY POSITION),
    POSITION
FROM EMP_HR;

-------------------------------TRIGGER------------------
CREATE OR REPLACE TRIGGER TRG_TEST_MAPPING_INS
    BEFORE INSERT ON DUMP_S_TESTING_TBL
    FOR EACH ROW
    ENABLE
DECLARE
    V_NAME VARCHAR2(100);
BEGIN
    -- THIS USER COLUMN BELOW WILL REFER TO THE SCHEMA OWNER
    SELECT
        USER INTO
        V_NAME
    FROM DUAL;
    
    DBMS_OUTPUT.PUT_LINE('YOU JUST INSERTED: '||V_NAME);
END;

-- TABLE AUDITING TRIGGER
create or replace TRIGGER TRG_MULTIPLE_TEST_MAPPING_INS
    BEFORE INSERT OR DELETE OR UPDATE ON DUMP_S_TESTING_TBL
    FOR EACH ROW
    ENABLE
DECLARE
    V_NAME VARCHAR2(100);
    V_DATE DATE;
BEGIN
    -- THIS USER COLUMN BELOW WILL REFER TO THE SCHEMA OWNER
    SELECT
        USER,SYSDATE INTO V_NAME,V_DATE
    FROM DUAL;

    IF INSERTING THEN
        INSERT INTO DUMP_AUDIT(NEW_NAME,OLD_NAME,USER_NAME,ENTRY_DATE,OPERATION)
        VALUES (:NEW.ID,NULL,V_NAME,V_DATE,'INSERT');
    ELSIF DELETING THEN
        INSERT INTO DUMP_AUDIT(NEW_NAME,OLD_NAME,USER_NAME,ENTRY_DATE,OPERATION)
        VALUES (NULL,:OLD.NAME,V_NAME,V_DATE,'DELETE');
    ELSIF UPDATING THEN
        INSERT INTO DUMP_AUDIT(NEW_NAME,OLD_NAME,USER_NAME,ENTRY_DATE,OPERATION)
        VALUES (:NEW.NAME,:OLD.NAME,V_NAME,V_DATE,'UPDATE');
    END IF;
END;

--------------------------------------------------------
---------------------INDEXES----------------------

--CREATE BTREE INDEX
CREATE INDEX B_TREE_EMP_NAME ON EMP_HR(NAME);

-- CREATE BITMAP INDEX
CREATE BITMAP INDEX BITMAP_EMP_POSITION ON EMP_HR(POSITION);

-- CREATE FUNCTION BASED INDEX
CREATE INDEX FN_EMP_NAME ON EMP_HR(UPPER(NAME));

--CREATE REVERSE INDEX:
CREATE INDEX RVR_EMP_SAL ON EMP_HR(SALARY) REVERSE;

--CREATE COMPOSITE INDEX
CREATE INDEX CMP_EMP_TBL ON EMP_HR(NIK,POSITION);
--------------------------------------------------------

--ARTHMETIC NULL & DUAL
SELECT 1+NULL
FROM DUAL;