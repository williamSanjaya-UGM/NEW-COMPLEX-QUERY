-- EXAMPLE OF USING SUBQUERY INSIDE WHERE BETWEEN CLAUSE

SELECT *
FROM CUST_ORDER_PAYMENT COP
WHERE ID BETWEEN (
    SELECT DISTINCT ROUND(CDO.MAST_ORDER_ID/2)
    FROM FOOD_BEVERAGES_INFO FBI
    JOIN CUST_DETAIL_ORDER CDO
    ON CDO.FOOD_ID=FBI.ID
    WHERE CDO.MAST_ORDER_ID=COP.ORDER_ID
) AND 70

--METHOD 1:
--USING THE INNER JOIN, REMEMBER: INSIDE THE INNER JOIN FROM SUBQUERY, THE SUBQUERY CANNOT TAKE THE OUTER VALUE FROM TABLE
SELECT *
FROM CASHIER_POS_RECORD CPR,
(
    SELECT 
        ID,
        NAME,
        NIK,
        POSITION,
        ROUND(AVG(SALARY)) AVG_SAL
    FROM EMP_HR
    GROUP BY ID, NAME, NIK,POSITION
)HR
WHERE HR.ID=CPR.CASHIER_ID;

-- METHOD 2:
-- USING THE INNER JOIN IN THE SELECT STATEMENT, SO THE SUBQUERY CAN ACCESS THE FROM "TABLE"
-- DOWNSIDE: CAN ONLY SELECT 1 COLUMN
SELECT CPR.*,
    (SELECT ROUND(AVG(SALARY)) AVG_SAL
    FROM EMP_HR HR
    WHERE HR.ID=CPR.CASHIER_ID) AVG_SAL
FROM CASHIER_POS_RECORD CPR;

-- METHOD 3:
-- LATERAL JOIN INLINE VIEW
-- SO THE INNER SUBQUERY CAN ACCESS THE INLINE "LEFT" TABLE
SELECT *
FROM CASHIER_POS_RECORD CPR,
LATERAL(
    SELECT 
        ID,
        NAME,
        NIK,
        POSITION,
        ROUND(AVG(SALARY)) AVG_SAL
    FROM EMP_HR HR
    WHERE HR.ID=CPR.CASHIER_ID
    GROUP BY ID, NAME, NIK,POSITION
)HR;

CREATE TABLE TEST_COMMA(DEPTNO NUMERIC,ENAME VARCHAR2(200))

INSERT INTO TEST_COMMA VALUES(10,'RAGHU, RAJU, RAVI');
INSERT INTO TEST_COMMA VALUES(20,'MOHAN, PRIYA');
INSERT INTO TEST_COMMA VALUES(30,'WIKI, KHAPUR');
INSERT INTO TEST_COMMA VALUES(40,'PRAVEEN');

--SPLIT COMMA TO EACH DIFFERENT ROW
SELECT
    DEPTNO,
    REGEXP_SUBSTR(ENAME,'\w+',1,L) ENAME
FROM TEST_COMMA,
LATERAL(
    SELECT
        ROWNUM L
    FROM DUAL
    CONNECT BY LEVEL <=REGEXP_COUNT(ENAME,',')+1
);

-------------------------------------------------------------------
--DECOUPLING, MESSAGE QUEUEING IN ORACLE, SIMPLE TEST STEP:
-- QUEING DOESN'T SOLVE THE PROBLEM, JUST PUT THE PROBLEM SOMEWHERE ELSE
CREATE OR REPLACE PROCEDURE SLOW_REQUEST
AS
BEGIN
    DBMS_SESSION.SLEEP(10);
    DBMS_OUTPUT.PUT_LINE('DONE');
END;

EXECUTE SLOW_REQUEST;

CREATE OR REPLACE TYPE OBJ_SLOW_REQUEST FORCE AS OBJECT(
    USERNAME VARCHAR2(30),
    REQUEST_INFO VARCHAR2(200)
);

BEGIN
    --CREATE QUEUE_TABLE CALLED '.slow_request_queue_tab', WITH THE PAYLOAD OBJ_SLOW_REQUEST
    DBMS_AQADM.CREATE_QUEUE_TABLE(
        QUEUE_TABLE         => USER || '.slow_request_queue_tab',
        QUEUE_PAYLOAD_TYPE  => USER || '.OBJ_SLOW_REQUEST'
    );
    
    --CREATE NEW QUEUE CALLED '.slow_request_queue' IN THE QUEUE_TABLE
    DBMS_AQADM.CREATE_QUEUE(
        QUEUE_NAME  => USER || '.slow_request_queue',
        QUEUE_TABLE => USER || '.slow_request_queue_tab'
    );
    
    --START THE QUEUE
    DBMS_AQADM.START_QUEUE(
        QUEUE_NAME  => USER || '.slow_request_queue',
        ENQUEUE     => TRUE
    );
END;

CREATE OR REPLACE PACKAGE PKG_SLOW_REQUEST_API AS
    
    PROCEDURE ENQUEUE (P_USERNAME IN VARCHAR2, P_REQUEST_INFO IN VARCHAR2);
    
    PROCEDURE DEQUEUE (P_USERNAME OUT VARCHAR2, P_REQUEST_INFO OUT VARCHAR2);
                    
    PROCEDURE PROCESS_REQUESTS_JOB;
END;

CREATE OR REPLACE PACKAGE BODY PKG_SLOW_REQUEST_API AS
    G_PROCESS_JOB_LOOP NUMERIC  :=100;
     
     PROCEDURE ENQUEUE (P_USERNAME IN VARCHAR2, P_REQUEST_INFO IN VARCHAR2)
     IS
        L_ENQUEUE_OPTIONS       DBMS_AQ.ENQUEUE_OPTIONS_T;
        L_MESSAGE_PROPERTIES    DBMS_AQ.MESSAGE_PROPERTIES_T;
        L_MESSAGE_HANDLE        RAW(16);    --RAW DATATYPE, USED TO STORE SMALL AMOUNT OF BINARY DATA
        L_SLOW_REQUEST_MSG      OBJ_SLOW_REQUEST;
     BEGIN
          L_SLOW_REQUEST_MSG:=OBJ_SLOW_REQUEST(P_USERNAME,P_REQUEST_INFO);
        
        DBMS_AQ.ENQUEUE(QUEUE_NAME          => USER || '.slow_request_queue',
                        ENQUEUE_OPTIONS     => L_ENQUEUE_OPTIONS,
                        MESSAGE_PROPERTIES  => L_MESSAGE_PROPERTIES,
                        PAYLOAD             => L_SLOW_REQUEST_MSG,
                        MSGID               => L_MESSAGE_HANDLE);
      END ENQUEUE;
     
     PROCEDURE DEQUEUE (P_USERNAME OUT VARCHAR2, P_REQUEST_INFO OUT VARCHAR2) AS
        L_DEQUEUE_OPTIONS       DBMS_AQ.DEQUEUE_OPTIONS_T;
        L_MESSAGE_PROPERTIES    DBMS_AQ.MESSAGE_PROPERTIES_T;
        L_MESSAGE_HANDLE        RAW(16);    --RAW DATATYPE, USED TO STORE SMALL AMOUNT OF BINARY DATA
        L_SLOW_REQUEST_MSG      OBJ_SLOW_REQUEST;
     BEGIN
        --DON'T WAIT ON THE QUEUE FOR A MESSAGE TO ARRIVE
        L_DEQUEUE_OPTIONS.WAIT := DBMS_AQ.NO_WAIT;
        
        DBMS_AQ.DEQUEUE(QUEUE_NAME          => USER || '.slow_request_queue',
                        DEQUEUE_OPTIONS     => L_DEQUEUE_OPTIONS,
                        MESSAGE_PROPERTIES  => L_MESSAGE_PROPERTIES,
                        PAYLOAD             => L_SLOW_REQUEST_MSG,
                        MSGID               => L_MESSAGE_HANDLE);
                        
        P_USERNAME      :=L_SLOW_REQUEST_MSG.USERNAME;
        P_REQUEST_INFO  :=L_SLOW_REQUEST_MSG.REQUEST_INFO;
     END;
     
     PROCEDURE PROCESS_REQUESTS_JOB AS
        L_USERNAME      VARCHAR2(30);
        L_REQUEST_INFO  VARCHAR2(200);
        
        EX_TIMEOUT      EXCEPTION;
        PRAGMA          EXCEPTION_INIT(EX_TIMEOUT,-25228);
     BEGIN
        -- DEQUEUEING ONE MESSAGE AT A TIME. COULD IMPROVE PERFORMANCE USING
        -- DBMS_AQ.DEQUEUE_ARRAY FOR ARRAY PROCESSING.
        FOR I IN 1..G_PROCESS_JOB_LOOP LOOP
            DEQUEUE(P_USERNAME      =>L_USERNAME,
                    P_REQUEST_INFO  =>L_REQUEST_INFO);
            SLOW_REQUEST;
        END LOOP;
        
        EXCEPTION
            WHEN EX_TIMEOUT THEN
                --QUEUE IS EMPTY.
                NULL;
     END;
END PKG_SLOW_REQUEST_API;

--TEST WITHOUT USING DECOUPLING
DECLARE
    L_START NUMERIC;
    L_LOOPS NUMERIC:=5;
BEGIN
    --TIME THE ORIGINAL METHOD
    L_START :=DBMS_UTILITY.GET_TIME;
    
    FOR I IN 1..L_LOOPS LOOP
        SLOW_REQUEST;
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('DECOUPLED METHOD: '||
                        (DBMS_UTILITY.GET_TIME-L_START)||' SECS');
END;

--TEST USING DECOUPLING ENQUEUEING
DECLARE
    L_START NUMERIC;
    L_LOOPS NUMERIC:=5;
BEGIN
    --TIME THE ORIGINAL METHOD
    L_START :=DBMS_UTILITY.GET_TIME;
    
    FOR I IN 1..L_LOOPS LOOP
        PKG_SLOW_REQUEST_API.ENQUEUE(
            P_USERNAME      => 'WILLIAMS',
            P_REQUEST_INFO  => 'THIS IS DUMMY DATA'
        );
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('DECOUPLED METHOD: '||
                        (DBMS_UTILITY.GET_TIME-L_START)||' SECS');
END;

--TEST DEQUEUEING
DECLARE
    L_START NUMERIC;
    L_LOOPS NUMERIC:=5;
BEGIN
    --TIME THE ORIGINAL METHOD
    L_START :=DBMS_UTILITY.GET_TIME;
    
    PKG_SLOW_REQUEST_API.PROCESS_REQUESTS_JOB;
    
    DBMS_OUTPUT.PUT_LINE('DECOUPLED METHOD: '||
                        (DBMS_UTILITY.GET_TIME-L_START)||' SECS');
END;


---------------------TESTING CONNECT BY PRIOR & VIEW ------------------------
SELECT *
FROM (
    SELECT 
        M.ID,
        M.NAME,
        M.DETAIL_ID,
        M.PARENT_ID,
        T.DEFINITION
    FROM TEST_MAPPING M
    JOIN MAPPER_TEST T
    ON T.ID=M.DETAIL_ID
) M
START WITH M.PARENT_ID IS NULL
CONNECT BY PRIOR M.ID=M.PARENT_ID;

CREATE VIEW VW_TEST_MAP AS
    SELECT 
        M.ID AS ID,
        M.NAME AS NAME,
        M.DETAIL_ID AS DETAIL_ID,
        NVL(CAST(M.PARENT_ID AS VARCHAR2(5)), 'KOSONG') AS PARENT_ID,
        M.DEFINITION AS DESKRIPSI
    FROM (
        SELECT 
            M.ID,
            M.NAME,
            M.DETAIL_ID,
            M.PARENT_ID,
            T.DEFINITION
        FROM TEST_MAPPING M
        JOIN MAPPER_TEST T
        ON T.ID=M.DETAIL_ID
    ) M
    START WITH M.PARENT_ID IS NULL
    CONNECT BY PRIOR M.ID=M.PARENT_ID;


-- BASIC EXAMPLE HOW TO CREATE MV WITH SOME REFRESH CONDITION
CREATE MATERIALIZED VIEW MV_TEST_MAP
    NOLOGGING
    CACHE
    BUILD IMMEDIATE
    REFRESH FORCE ON DEMAND
    AS
        SELECT 
            M.ID AS ID,
            M.NAME AS NAME,
            M.DETAIL_ID AS DETAIL_ID,
            NVL(CAST(M.PARENT_ID AS VARCHAR2(5)), 'KOSONG') AS PARENT_ID,
            M.DEFINITION AS DESKRIPSI
        FROM (
            SELECT 
                M.ID,
                M.NAME,
                M.DETAIL_ID,
                M.PARENT_ID,
                T.DEFINITION
            FROM TEST_MAPPING M
            JOIN MAPPER_TEST T
            ON T.ID=M.DETAIL_ID
        ) M
        START WITH M.PARENT_ID IS NULL
        CONNECT BY PRIOR M.ID=M.PARENT_ID;

-----------------------------------------------------------------------------
----------------------------CONNECT BY LEVEL ---------------------------

-- GENERATE A CALENDAR
-- LAST_DAY, TO GET THE LAST DAY
-- ADD_MONTHS(LAST_DAY(SYSDATE),-1), -1 : LAST MONTH, GET THE LAST DAY OF LAST MONTH
-- +LEVEL, SO IT WILL ADDING FROM THE LAST DAY IN LAST MONTH UNTIL THE LAST DAY IN THIS MONTH
-- TO_CHAR, CONVERT NUMBER/DATE TO STRING
SELECT
    DAYS,
    LISTAGG(TO_CHAR(MONTH_DATES,'DD'),' ') WITHIN GROUP(ORDER BY MONTH_DATES) DATES
FROM(
    SELECT 
        MONTH_DATES,
        TO_CHAR(MONTH_DATES,'DY') DAYS
    FROM (
        SELECT ADD_MONTHS(LAST_DAY(SYSDATE),-1)+LEVEL MONTH_DATES
        FROM DUAL 
        CONNECT BY LEVEL<=TO_CHAR(LAST_DAY(SYSDATE),'DD')
    )
) GROUP BY DAYS
ORDER BY CASE 
            WHEN DAYS='SUN' THEN 1
            WHEN DAYS='MON' THEN 2
            WHEN DAYS='TUE' THEN 3
            WHEN DAYS='WED' THEN 4
            WHEN DAYS='THU' THEN 5
            WHEN DAYS='FRI' THEN 6
            WHEN DAYS='SAT' THEN 7
        END;


--CONNECT BY LEVEL WITH DATE, WILL SHOW NUMBER 1 UNTIL LAST DAY SYSDATE
SELECT LEVEL
FROM DUAL
CONNECT BY LEVEL<=TO_CHAR(LAST_DAY(SYSDATE),'DD');

-- IF ABOVE ADD BY DATE, IT WILL GIVE NEXT MONTH + 31 DAY
SELECT LEVEL+LAST_DAY(SYSDATE)
FROM DUAL
CONNECT BY LEVEL<=TO_CHAR(LAST_DAY(SYSDATE),'DD');

-- IT WILL SHOW THIS MONTH DATES
SELECT LEVEL+ADD_MONTHS(LAST_DAY(SYSDATE),-1)
FROM DUAL
CONNECT BY LEVEL<=TO_CHAR(LAST_DAY(SYSDATE),'DD');

-- STRING SPLIT BY COMMA, BELOW WILL SHOW NUMBER 1 UNTIL 4
SELECT
        ROWNUM L
    FROM DUAL
    CONNECT BY LEVEL <=REGEXP_COUNT('RAGHU, RAHVAR, TAVIR, WISHKAS',',')+1

-- SOME MORE WITH STRING AND REGEXP
-- SPLIT EACH COMMA TO DIFFERENT ROWS
SELECT 
    REGEXP_SUBSTR('JIMMY, JOHN, SADLY, WISHKAS','\w+',L,L)
FROM (
    SELECT
        ROWNUM L
    FROM DUAL
    CONNECT BY LEVEL <=REGEXP_COUNT('RAGHU, RAHVAR, TAVIR, WISHKAS',',')+1
)

SELECT 
    REGEXP_SUBSTR('RAGHU, RAHVAR, TAVIR, WISHKAS','\w+',L,L)
FROM (
    SELECT
        ROWNUM L
    FROM DUAL
    CONNECT BY LEVEL <=REGEXP_COUNT('RAGHU, RAHVAR, TAVIR, WISHKAS',',')+1
)

SELECT 
    REGEXP_SUBSTR('JIMMY, JOHN, SADLY, WISHKAS','\w+',L,L)
FROM (
    SELECT
        ROWNUM L
    FROM DUAL
    CONNECT BY LEVEL <=5
)

BEGIN
    -- FOR LOOP IN CURSOR
    FOR I IN (
        SELECT
            DEPTNO,
            REGEXP_SUBSTR(ENAME,'\w+',L,L) ENAME
        FROM TEST_COMMA,
        LATERAL(
            SELECT
                ROWNUM L
            FROM DUAL
            CONNECT BY LEVEL <=REGEXP_COUNT(ENAME,',')+1
        )
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('DEPT: '||I.DEPTNO||' '||I.ENAME);
    END LOOP;
END;

------CURSOR-------
create or replace PROCEDURE USP_DIFFERENT_CURSOR_1(
    P_ORDER_ID IN NUMERIC
)AS
    TYPE REC_CUR_1 IS RECORD(
        ORDER_ID NUMERIC,
        TRANSACTION_ID NUMERIC,
        TABLE_ID NUMERIC
    );
    L_CUR_1 REC_CUR_1;
    
    -- EXPLICIT CURSOR
    CURSOR V_CUR_1 IS
        SELECT 
            C.ORDER_ID ORDER_ID,
            P.TRANSACTION_ID TRANSACTION_ID,
            C.TABLE_ID TABLE_ID
        FROM CUST_MAST_ORDER C
        JOIN CUST_ORDER_PAYMENT P
            ON C.ORDER_ID=P.ORDER_ID
        WHERE
            C.ORDER_ID=P_ORDER_ID;
            
    -- FOR UPDATE WILL LOCK THE ROW IN THE SESSION UNTIL THE TRANSACTION FINISH
    CURSOR V_CUR_2 IS
        SELECT ORDER_ID
        FROM CUST_MAST_ORDER
        WHERE ORDER_ID=P_ORDER_ID
    FOR UPDATE;
    
    --EXPLICIT PARAMETERIZED CURSOR
    CURSOR V_CUR(V_ORDER IN NUMERIC) IS
        SELECT 
            C.ORDER_ID ORDER_ID,
            P.TRANSACTION_ID TRANSACTION_ID,
            C.TABLE_ID TABLE_ID
        FROM CUST_MAST_ORDER C
        JOIN CUST_ORDER_PAYMENT P
            ON C.ORDER_ID=P.ORDER_ID
        WHERE
            C.ORDER_ID=V_ORDER;
            
    --REF CURSOR (DYNAMIC CURSOR). REF CURSOR IS DATA TYPE
    TYPE REF_CUR IS REF CURSOR;
    V_REF_CUR REF_CUR;
    
    V_ORDER_CUR_ID NUMERIC;
    V_TABLE_CUR_ID NUMERIC;
    V_TRANSACTION_CUR_ID NUMERIC;
    
    --STRONG TYPE REF CURSOR, CAN ONLY RETURN 'SOME_DATATYPE'
    TYPE STRONG_CUR IS REF CURSOR RETURN REC_CUR_1;
    V_STRONG_CUR STRONG_CUR;
    
    --SYS_REFCURSOR IS ALWAYS WEAK TYPE REFCURSOR
    V_SYS_CUR SYS_REFCURSOR;
BEGIN
    --FOR LOOP IN CURSOR WILL AUTOMATICALLY DOING OPEN CURSOR, SO IF YOU ALREADY OPEN CURSOR USING FOR LOOP IS IMPOSSIBLE
    -- CURSOR CAN BE GLOBALLY DECLARED (BY USING PACKAGES), REF CURSOR IS NOT
    -- REF CURSOR CAN BE PASSED ALONG PLSQL SUBPROGRAM, CURSOR IS NOT
    
    --EXPLICIT CURSOR
    --UPDATING BY USING EXPLICIT CURSOR & WHERE CURRENT OF
    OPEN V_CUR_1;
    LOOP
        FETCH V_CUR_1 INTO L_CUR_1;
        EXIT WHEN V_CUR_1%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(L_CUR_1.ORDER_ID||' '||L_CUR_1.TRANSACTION_ID);
    END LOOP;
    
    --EXPLICIT PARAMETERIZED CURSOR
    OPEN V_CUR(P_ORDER_ID);
    LOOP
        FETCH V_CUR INTO L_CUR_1;
        EXIT WHEN V_CUR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('PARAMETERIZED: '||L_CUR_1.ORDER_ID||' '||L_CUR_1.TRANSACTION_ID);
    END LOOP;
    
    -- REF CURSOR
    -- REF CURSOR IS DYNAMIC BECAUSE YOU CAN OPEN CURSOR FOR DIFFERENT KIND OF SELECT, AND ALSO DYNAMIC SQL
    OPEN V_REF_CUR FOR 
        SELECT 
            C.ORDER_ID ORDER_ID,
            P.TRANSACTION_ID TRANSACTION_ID,
            C.TABLE_ID TABLE_ID
        FROM CUST_MAST_ORDER C
        JOIN CUST_ORDER_PAYMENT P
            ON C.ORDER_ID=P.ORDER_ID
        WHERE
            C.ORDER_ID=P_ORDER_ID;
    LOOP
        FETCH V_REF_CUR INTO L_CUR_1;
        EXIT WHEN V_REF_CUR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('REF: '||L_CUR_1.ORDER_ID||' '||L_CUR_1.TRANSACTION_ID);
    END LOOP;
    CLOSE V_REF_CUR;
    
    OPEN V_REF_CUR FOR 
        SELECT 
            C.ORDER_ID ORDER_ID,
            C.TABLE_ID TABLE_ID
        FROM CUST_MAST_ORDER C
        WHERE
            C.ORDER_ID=P_ORDER_ID;
    LOOP
        FETCH V_REF_CUR INTO V_ORDER_CUR_ID,V_TABLE_CUR_ID;
        EXIT WHEN V_REF_CUR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('REF: '||V_ORDER_CUR_ID||' '||V_TABLE_CUR_ID);
    END LOOP;
    CLOSE V_REF_CUR;
    
    OPEN V_REF_CUR FOR 
        'SELECT 
            C.ORDER_ID ORDER_ID,
            C.TABLE_ID TABLE_ID
        FROM CUST_MAST_ORDER C
        WHERE
            C.ORDER_ID='||P_ORDER_ID;
    LOOP
        FETCH V_REF_CUR INTO V_ORDER_CUR_ID,V_TABLE_CUR_ID;
        EXIT WHEN V_REF_CUR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('REF DYNAMIC: '||V_ORDER_CUR_ID||' '||V_TABLE_CUR_ID);
    END LOOP;
    CLOSE V_REF_CUR;
    
    --STRONG TYPE REF CURSOR
    OPEN V_STRONG_CUR FOR 
        SELECT 
            C.ORDER_ID ORDER_ID,
            P.TRANSACTION_ID TRANSACTION_ID,
            C.TABLE_ID TABLE_ID
        FROM CUST_MAST_ORDER C
        JOIN CUST_ORDER_PAYMENT P
            ON C.ORDER_ID=P.ORDER_ID
        WHERE
            C.ORDER_ID=P_ORDER_ID;
    LOOP
        FETCH V_STRONG_CUR INTO L_CUR_1;
        EXIT WHEN V_STRONG_CUR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('STRONG REF: '||L_CUR_1.ORDER_ID||' '||L_CUR_1.TRANSACTION_ID);
    END LOOP;
    CLOSE V_STRONG_CUR;
    
    OPEN V_SYS_CUR FOR
        SELECT 
            C.ORDER_ID ORDER_ID,
            P.TRANSACTION_ID TRANSACTION_ID,
            C.TABLE_ID TABLE_ID
        FROM CUST_MAST_ORDER C
        JOIN CUST_ORDER_PAYMENT P
            ON C.ORDER_ID=P.ORDER_ID
        WHERE
            C.ORDER_ID=P_ORDER_ID;
    LOOP
        FETCH V_SYS_CUR INTO V_ORDER_CUR_ID,V_TRANSACTION_CUR_ID,V_TABLE_CUR_ID;
        EXIT WHEN V_SYS_CUR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('SYS_REF: '||V_ORDER_CUR_ID||' '||V_TRANSACTION_CUR_ID||' '||V_TABLE_CUR_ID);
    END LOOP;
    
    -- "WHERE CURRENT OF" CAN ONLY BE USED IF YOU USING "FOR UPDATE" CLAUSE IN THE CURSOR
    -- "WHERE CURRENT OF" WILL POINTING TO THE CURRENT CURSOR MEMORY LOCATION
    -- "WHERE CURRENT OF" CANNOT BE USED IF SELECT JOIN STATEMENT
    OPEN V_CUR_2;
    LOOP
        FETCH V_CUR_2 INTO V_ORDER_CUR_ID;
        EXIT WHEN V_CUR_2%NOTFOUND;
        
        UPDATE CUST_MAST_ORDER
        SET ORDER_STATUS='TAKEAWAY'
        WHERE CURRENT OF V_CUR_2;
        DBMS_OUTPUT.PUT_LINE('ROWS UPDATED: '||SQL%ROWCOUNT);
    END LOOP;
END;

--CREATING GLOBAL CURSOR USING PACKAGE
CREATE OR REPLACE PACKAGE TEST_PACKAGE_CUR AS
    CURSOR LV_CUR IS
        SELECT * FROM DUMP_S_TESTING_TBL;
END TEST_PACKAGE_CUR;